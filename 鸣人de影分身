我们的主角漩涡鸣人所拥有的一个招数——多重影分身之术——就是一个很好的例子。影分身是由鸣人身体的查克拉能量制造的，使用的查克拉越多，制造出的影分身越强。
针对不同的作战情况，鸣人可以选择制造出各种强度的影分身，有的用来佯攻，有的用来发起致命一击。那么问题来了，假设鸣人的查克拉能量为 M，他影分身的个数最多为 N，那么制造影分身时有多少种不同的分配方法？
注意：影分身可以分配0点能量。分配方案不考虑顺序，例如：M=7,N=3，那么 (2,2,3) 和 (2,3,2) 被视为同一种方案。输入格式第一行是测试数据的数目 t。
以下每行均包含二个整数 M 和 N，以空格分开。输出格式对输入的每组数据 M和 N，用一行输出分配的方法数。
数据范围0≤t≤20,
1≤M,N≤10

#include<cstdio>
#include<algorithm>
//以分组后的查克拉是否为0，分为两组
// min=0,f[i][j]=f[i][j-1]
// min!=0,f[i][j]组内同时减取1，一一映射唯一的，f[i][j]=f[i-j][j],前提是i>j
using namespace std;
const int N =11;
int T;
int f[N][N];
int main()
{
    scanf("%d\n", &T);
    while(T--)
    {
        int m,n;
        scanf("%d%d",&m,&n);
        f[0][0]=1;
     for(int i = 0;i<=m;i++)
       for(int j = 1;j<=n;j++)
        {
          f[i][j]=f[i][j-1];
          if(i>=j) f[i][j]+=f[i-j][j];
        }
      printf("%d\n",f[m][n]);
    }
    return 0;
    
